#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import logging
from jumpssh import SSHSession

logger = logging.getLogger(__name__)

"""
Class for managing SSH connections
"""


class Session:
    def __init__(self, topology, target):
        self._connected = False

        # Variables
        self._connections = []

        # Find way to target
        self._tool_is_host = True

        target_topology = [(k, v) for k, v in topology.items() if v["host"] == target][
            0
        ]

        if target_topology[1]["parent"] != "tool":
            self._tool_is_host = False

        # Filter and get only the important path in topology
        self._topology = []
        current = target_topology[0]
        for _ in range(len(topology.keys())):
            self._topology.insert(0, topology[current])

            current = topology[current]["parent"]

            # Break if reached null target
            if current is None:
                break

    """
    Get sudo with password
    """

    def _get_sudo_cmd(self, cmd, index):
        return f"echo {self._topology[index]['password']} | sudo -S sh -c '{cmd}'"

    """
    Runs cmd on preceding host
    """

    def run_cmd(self, cmd, use_sudo=True):
        # Join if list
        if type(cmd) == list:
            cmd = " ".join(cmd)

        # Run command if connections allow for such
        if use_sudo:
            self._connections[-2].run_cmd(self._get_sudo_cmd(cmd, -2), silent=True)
        else:
            self._connections[-2].run_cmd(cmd, silent=True)

    """
    Runs cmd on target
    """

    def run_cmd_target(self, cmd, use_sudo=True):
        # Join if list
        exec_cmd = cmd
        if type(cmd) == list or type(cmd) == set:
            exec_cmd = " ".join(str(v) for v in cmd)

        # Run command if connections allow for such
        if self._connections[-1] is not None:
            if use_sudo:
                self._connections[-1].run_cmd(self._get_sudo_cmd(exec_cmd, -1), silent=True)
            else:
                self._connections[-1].run_cmd(exec_cmd, silent=True)

    """
    Runs cmd on preceding host
    """

    def get_cmd(self, cmd, use_sudo=True):
        # Join if list
        if type(cmd) == list:
            cmd = " ".join(cmd)

        # Run command if connections allow for such
        return self._connections[-2].get_cmd_output(
            cmd, username=self._topology[-2]["user"]
        )

    """
    Runs cmd on target
    """

    def get_cmd_target(self, cmd, use_sudo=True):
        # Join if list
        if type(cmd) == list:
            cmd = " ".join(cmd)

        # Run command if connections allow for such
        if self._connections[-1] is not None:
            return self._connections[-1].get_cmd_output(cmd)

    """
    """

    def connect_ssh(self):
        self._connected = True

        # Create SSH connection to tool host
        self._connections.append(
            SSHSession(
                self._topology[0]["host"],
                self._topology[0]["user"],
                password=self._topology[0]["password"],
                look_for_keys=False,
                auth_timeout=30,
                timeout=12000,
            ).open()
        )

        # Create connection to all targets within the fixed topology
        for i in range(1, len(self._topology)):
            # check if last
            if i == len(self._topology) - 1:
                try:
                    self._connections.append(
                        self._connections[i - 1].get_remote_session(
                            self._topology[i]["host"],
                            self._topology[i]["user"],
                            password=self._topology[i]["password"],
                            look_for_keys=False,
                            auth_timeout=30,
                            timeout=12000,
                        )
                    )
                except Exception:
                    self._connections.append(None)
                    logger.warn("Could not connect to target over SSH, skipping internal actions")
            else:
                self._connections.append(
                    self._connections[i - 1].get_remote_session(
                        self._topology[i]["host"],
                        self._topology[i]["user"],
                        password=self._topology[i]["password"],
                        look_for_keys=False,
                        auth_timeout=30,
                        timeout=12000,
                    )
                )
                    

    """
    Get file from remote preceding host
    """

    def get_file(self, remote_path, local_path, use_sudo=False, username=None):
        if self._connected:
            if len(self._connections) > 1:
                return self._connections[-2].get(
                    remote_path=remote_path,
                    local_path=local_path,
                    use_sudo=use_sudo,
                    username=username,
                )
            else:
                raise Exception("More than 1 connections must be present")

        raise Exception("Session is not connected")

    """
    Get file from remote target host
    """

    def get_file_target(self, remote_path, local_path, use_sudo=False, username=None):
        if len(self._connections) > 0:
            return self._connections[-1].get(
                remote_path, local_path, use_sudo, username
            )
        else:
            raise Exception("More than 0 connections must be present")

    """
    Disconnect from all SSH hosts
    """

    def disconnect(self):
        self._connected = False

        for con in self._connections:
            if con is not None:
                con.close()

    def target_connected(self):
        if self._connections[-1] is None:
            return False
        return True