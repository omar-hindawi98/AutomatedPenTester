#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from abc import ABC, abstractmethod
import logging
from core.constants import EXTERNAL, INTERNAL
from core.helper import logger_class, remove_suffix, tool_config
import importlib
import json
import os
import inspect

logger = logging.getLogger(__name__)

'''
Abstract class for Modules
'''
class Module(ABC):
    def __init__(self, config, general_config, session, payload):
        # Configs
        self._config = config # Module config
        self._general_config = general_config # Run config
        self._target = general_config["target"]  # Target
        self._tool_config = tool_config()["General"] # Tool config

        # Module payload
        self._payload = payload

        # SSH session
        self._session = session

        # Module setups
        self._type = []
        self._services = []
        self._defaults = {}

        # Result holder
        self._result = None

        # Temporary location to save result
        self._res_name = remove_suffix(self.__class__.__name__, "Module").lower() + "_result"
        self._tmp = self._tool_config["rlocation"]

    @abstractmethod
    def init():
        pass

    @abstractmethod
    def run():
        pass

    @abstractmethod
    def parse():
        pass

    '''
    Helper function to get the temporary file location
    '''
    def _tmpfile_loc(self):
        return self._tmp + self._res_name + self._extension

    '''
    Gets result from performed command
    '''
    def get_result(self):
        local_path = f'{os.getcwd()}/targets/{self._target}/results/'

        if self._target_type == INTERNAL:
            logger_class(self, "Getting file from remote target", "debug")
            self._session.get_file_target(self._tmp + self._res_name + self._extension, local_path + self._res_name + self._extension)
            logger_class(self, "Finished getting file from remote target", "debug")
        elif self._target_type == EXTERNAL:
            logger_class(self, "Getting file from intermediate remote target", "debug")
            self._session.get_file(self._tmp + self._res_name + self._extension, local_path + self._res_name + self._extension)
            logger_class(self, "Finished getting file from intermediate remote target", "debug")

    '''
    Runs CMD on Session
    run_cmd(cmd, username=None, raise_if_error=True, continuous_output=False, silent=False, 
    timeout=None, input_data=None, success_exit_code=0, retry=0, retry_interval=5, keep_retry_history=False)
    '''
    def run_cmd(self, cmd):
        self._session.run_cmd(cmd)

    '''
    Checks all regression cases in module file
    '''
    def check_regtests(self):
        # Get class name
        module_name = remove_suffix(self.__class__.__name__, "Module").lower()

        # SKIP Threading here, locking is -_-
        # Check each regression test in module file
        for name, cls in inspect.getmembers(importlib.import_module(f'modules.{module_name.lower()}'), inspect.isclass):
            if name.endswith("Regression"):
                regtest = cls(self._result, self._session)
                res = regtest.check()
                reg_name = remove_suffix(name, "Regression")

                file_path = os.path.join(f'{os.getcwd()}/targets', self._general_config["target"]) + f"/regtests/{module_name}.json"

                # Create or append to regression test file if found
                if res:
                    data = {}

                    if os.path.exists(file_path):
                        with open(file_path, 'r') as f:
                            data = json.load(f)

                        # Replace old regression (Or instert new)
                        data[reg_name] = res

                        # Append to json
                        with open(file_path, 'w') as f:
                            json.dump(data, f, indent=4, sort_keys=True)
                    else:
                        data[reg_name] = res
                        # Create new file with json
                        with open(file_path, 'w') as f:
                            json.dump(data, f, indent=4, sort_keys=True)